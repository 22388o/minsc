use crate::ast::{Expr, Stmt, self};
use crate::util::concat;

grammar;

// Enable `//` comments
match {
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    _,
}

pub Program: Expr = Block;

Block: Expr = <stmts:Stmt*> <ret:Expr> =>
  ast::Block { stmts,  return_value: ret.into() }.into();

Stmt: Stmt = {
  FnDef,
  Assign,
}

Expr: Expr = {
  SimpleExpr,
  And,
  Or,
  ArrayAccess,
};

SimpleExpr: Expr = {
  TermWord,
  Call,
  Thresh,
  BlockExpr,
  WithProb,
  Array,
  Paren<And>,
  Paren<Or>,
  Paren<ArrayAccess>,
  Paren<SimpleExpr>,
};

// Expressions

Ident: String = <s:r"[\w$]+"> => (<>).to_owned();

TermWord: Expr = Ident => ast::TermWord(<>.into()).into();

Call: Expr = <ident:Ident> "(" <args:List0<Expr, ",">> ")" =>
    ast::Call { ident, args }.into();

And: Expr = <List2<SimpleExpr, "&&">> => ast::And(<>).into();
Or: Expr = <List2<SimpleExpr, "||">> => ast::Or(<>).into();

Thresh: Expr = <thresh:TermWord> "of" <policies:SimpleExpr> =>
  ast::Thresh { thresh: thresh.into(), policies: policies.into() }.into();

BlockExpr: Expr = "{" <Block> "}" => <>.into();

WithProb: Expr = <prob:TermWord> "@" <expr:SimpleExpr> =>
    ast::WithProb { prob: prob.into(), expr: expr.into() }.into();

Array: Expr = "[" <List0<Expr, ",">> "]" =>
  ast::Array(<>).into();

ArrayAccess: Expr = <array:Expr> "." <index:TermWord> =>
  ast::ArrayAccess { array: array.into(), index: index.into() }.into();

// Statements

Assign: Stmt = "let"? <assigns:List1<Assignment, ",">> ";" =>
    ast::Assign(assigns).into();

Assignment: ast::Assignment = <lhs:Ident> "=" <rhs:Expr> =>
    ast::Assignment { lhs, rhs };

FnDef: Stmt = {
    "fn" <ident:Ident> "(" <signature:List0<Ident, ",">> ")" "=" <body:Expr> ";" =>
        ast::FnDef { ident, signature, body }.into(),
    "fn" <ident:Ident> "(" <signature:List0<Ident, ",">> ")" "{" <body:Block> "}" ";"? =>
        ast::FnDef { ident, signature, body }.into(),
}

// A `S`-separated list of zero or more `T` values
List0<T, S>: Vec<T> = <l:(<T> S)*> <t:T?> => concat(l, t);

// A `S`-separated list of one or more `T` values
List1<T, S>: Vec<T> = <l:(<T> S)*> <t:T> => concat(l, Some(t));

// A `S`-separated list of two or more `T` values
List2<T, S>: Vec<T> = <l:(<T> S)+> <t:T> => concat(l, Some(t));

Paren<T> = "(" <T> ")";
