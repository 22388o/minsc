use minis::ast::{Expr, self};
use minis::util::concat;

grammar;

pub Expr: Expr = {
  //Var,
  FnCall,
  FnDef,
  Assign,
  And,
  Or,
  Value,
  Block,
};

Ident: String = <s:r"[\w$]+"> => (<>).to_owned();

Value: Expr = Ident => ast::Value(<>.into()).into();

Assign: Expr = "let" <name:Ident> "=" <value:Expr> =>
    ast::Assign { name, value: value.into() }.into();

FnCall: Expr = <name:Ident> "(" <args:List<Expr, ",">> ")" =>
    ast::FnCall { name, args }.into();

FnDef: Expr = {
    "fn" <name:Ident> "(" <args:List<Ident, ",">> ")" "=" <body:Expr> =>
        ast::FnDef { name, args, body: body.into() }.into(),
    "fn" <name:Ident> "(" <args:List<Ident, ",">> ")" <body:Block> =>
        ast::FnDef { name, args, body: body.into() }.into(),
};

// TODO make the () optional
Or: Expr = "(" <ListM<Expr, "||">> ")" => ast::Or(<>).into();
And: Expr = "(" <ListM<Expr, "&&">> ")" => ast::And(<>).into();

// XXX can the ';' be optional?
Block: Expr = "{" <List<Expr, ";">> "}" => ast::Block(<>).into();

// A `S`-separated list of *one* or more `T` values, *with* an optional suffix separator
List<T, S>: Vec<T> = <l:(<T> S)*> <t:T> S? => concat(l, t);

// A `S`-separated list of *two* or more `T` values, *without* an optional suffix separator
ListM<T, S>: Vec<T> = <l:(<T> S)+> <t:T> => concat(l, t);




//Value: Expr = <s:r"\w+"> => Expr::Value(<>.into());
//Var: Expr = Ident => Expr::Var(<>.into());
