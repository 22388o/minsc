use crate::ast::{Expr, Stmt, self};
use crate::util::concat;

grammar;

pub Program: Expr = Block;

Block: Expr = <stmts:Stmt*> <ret:Expr> =>
  ast::Block { stmts,  return_value: ret.into() }.into();

Expr: Expr = {
  Call,
  And,
  Or,
  TermWord,
  BlockExpr,
}

Stmt: Stmt = {
  FnDef,
  Assign,
}

// Expressions

TermWord: Expr = Ident => ast::TermWord(<>.into()).into();

Call: Expr = <ident:Ident> "(" <args:List<Expr, ",">> ")" =>
    ast::Call { ident, args }.into();

// TODO make the () optional
Or: Expr = "(" <ListM<Expr, "||">> ")" => ast::Or(<>).into();
And: Expr = "(" <ListM<Expr, "&&">> ")" => ast::And(<>).into();

BlockExpr: Expr = "{" <Block> "}" => <>.into();

// Statements

Assign: Stmt = "let"? <lhs:Ident> "=" <rhs:Expr> ";" =>
    ast::Assign { lhs, rhs }.into();

FnDef: Stmt = {
    "fn" <ident:Ident> "(" <signature:List<Ident, ",">> ")" "=" <body:Expr> ";" =>
        ast::FnDef { ident, signature, body }.into(),
    "fn" <ident:Ident> "(" <signature:List<Ident, ",">> ")" "{" <body:Block> "}" ";"? =>
        ast::FnDef { ident, signature, body }.into(),
}


Ident: String = <s:r"[\w$]+"> => (<>).to_owned();

// A `S`-separated list of *zero* or more `T` values
List<T, S>: Vec<T> = <l:(<T> S)*> <t:T?> => concat(l, t);

// A `S`-separated list of *two* or more `T` values
ListM<T, S>: Vec<T> = <l:(<T> S)+> <t:T> => concat(l, Some(t));
